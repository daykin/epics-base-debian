From: Bruno Martins <martins@frib.msu.edu>
Date: Mon, 6 May 2019 09:35:08 -0400
Subject: libca: don't set thread local storage handle to zero on cleanup

cacExitHandler used to set caClientCallbackThreadId to zero. This
is fine when the IOC is the only user of the dynamically-loaded
libca. However, when an IOC is used with pyDevSup and pyepics,
pyepics ends up depending on the already-loaded libca. At IOC exit,
pyepics tries to cleanup its resources but can't, since its thread-
local storage handle was being zeroed out, which led to a SEGFAULT.

See discussion on https://epics.anl.gov/tech-talk/2019/msg00778.php
---
 src/ca/client/ca_client_context.cpp | 1 -
 1 file changed, 1 deletion(-)

diff --git a/src/ca/client/ca_client_context.cpp b/src/ca/client/ca_client_context.cpp
index 20a6e84..95cd6cb 100644
--- a/src/ca/client/ca_client_context.cpp
+++ b/src/ca/client/ca_client_context.cpp
@@ -48,7 +48,6 @@ const unsigned ca_client_context :: flushBlockThreshold = 0x58000;
 extern "C" void cacExitHandler ( void *)
 {
     epicsThreadPrivateDelete ( caClientCallbackThreadId );
-    caClientCallbackThreadId = 0;
     delete ca_client_context::pDefaultServiceInstallMutex;
 }
 
